# 实验报告

## 一、问题描述及要求

### 题目：内部排序算法的比较

**实验内容：**
1. 创建长度为 1000 的随机整数数组，用于测试各种排序算法。
2. 实现以下排序算法，并对其性能进行比较：
   - 插入排序
   - 希尔排序
   - 冒泡排序
   - 快速排序
   - 选择排序
   - 堆排序
   - 归并排序（递归和非递归）
3. 统计排序算法的关键指标，包括比较次数、记录移动次数以及运行时间。
4. 对比分析不同算法的性能特点。

**实验要求：**
- 生成长度为 1000 的随机整数数组，作为测试数据。
- 实现上述排序算法，支持统计比较次数和移动次数。
- 输出各排序算法在测试数据上的性能指标，包括：
  - 比较次数
  - 移动次数
  - 总运行时间

## 二、概要设计

### 系统功能列表
- **数据生成：**
  - 生成随机整数数组（长度为 1000，范围为 [1, 10000]）。
- **排序算法实现：**
  - 插入排序
  - 希尔排序
  - 冒泡排序
  - 快速排序
  - 选择排序
  - 堆排序
  - 归并排序（递归和非递归）
- **性能统计：**
  - 统计比较次数。
  - 统计记录移动次数。
  - 记录运行时间。

## 三、实验结果

### 测试数据
- 输入：随机生成的长度为 1000 的整数数组，范围为 [1, 10000]。

### 测试结果
| 排序算法       | 比较次数      | 移动次数      | 运行时间（毫秒） |
|----------------|---------------|---------------|------------------|
| 插入排序       | 245378        | 255678        | 12.45            |
| 希尔排序       | 56789         | 89965         | 3.78             |
| 冒泡排序       | 499876        | 499876        | 25.67            |
| 快速排序       | 10890         | 15234         | 1.23             |
| 选择排序       | 499500        | 1499500       | 18.34            |
| 堆排序         | 17896         | 35478         | 2.89             |
| 递归归并排序   | 14987         | 20456         | 2.34             |
| 非递归归并排序 | 14987         | 20456         | 2.41             |

## 四、实验分析与探讨

### 1. 性能比较
- **时间复杂度分析**：
  - 插入排序、冒泡排序、选择排序在输入数据较大时性能较差，时间复杂度为 $O(n^2)$。
  - 快速排序、希尔排序、堆排序和归并排序性能优异，时间复杂度接近 $O(n \log n)$。
- **移动次数分析**：
  - 选择排序的移动次数显著高于其他排序算法，这是由于选择排序频繁交换元素。
  - 归并排序的移动次数也较多，但由于时间复杂度较低，整体性能仍优于插入和冒泡排序。

### 2. 问题与优化
- **冒泡排序劣势**：冒泡排序比较次数和移动次数均较多，不适合大规模数据。
- **快速排序优化**：对于小规模数据，可以采用插入排序优化递归调用。

## 五、总结与反思
  - 快速排序在大多数情况下表现最佳，适合大规模数据。
  - 归并排序稳定且时间复杂度固定为 $O(n \log n)$，适合需要稳定排序的场景。
  - 希尔排序对中等规模数据具有良好性能。