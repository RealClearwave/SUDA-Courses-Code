# 实验报告

## 一、问题描述及要求

### 1. 问题描述和要求

本实验要求使用C++设计并实现一个程序，通过递归的方法从给定的正整数 $ n $ （$ 1 \leq n \leq 2001 $）出发，生成新的整数序列。具体生成规则如下：

1. 每次可以在 $ n $ 的左边放置一个小于等于 $ n/2 $ 的整数 $ m $，形成新的整数 $ mn $。
2. 如果 $ m $ 左边仍然可以放置小于等于 $ m/2 $ 的整数 $ k $，则继续将 $ k $ 放置在 $ mn $ 的左边，形成新的整数 $ kmn $。
3. 如此递归地执行，直到无法继续为止。

例如，当 $ n = 8 $ 时，可以生成的整数序列包括：8, 18, 28, 38, 48, 128, 138, 148, 248, 1248。最终，程序需要计算所有可能生成的整数总数，并按照优先级队列的顺序输出这些整数。

## 二、概要设计

### 1. 系统功能列表

**功能实现**：
- 递归地生成所有符合条件的整数。
- 使用优先级队列 `priority_queue` 存储生成的整数，以便按顺序输出。

### 2. 程序运行设计

程序要求用户输入一个正整数 $ n $，并自动生成所有可能的整数组合，输出总数并按从大到小的优先级顺序打印所有生成的整数。

## 三、详细设计

### 1. 数据结构设计

#### 优先级队列 `priority_queue`
使用 `priority_queue` 存储生成的整数节点，并定义自定义排序规则，使得较短的整数优先排列，若长度相同，则按字典序排序。

### 2. 核心结构与函数

#### 自定义结构体 `node`
- **属性**：
  - `string val`: 存储整数的字符串形式。
  - `int len`: 存储整数字符串的长度，用于排序。
- **构造函数**：初始化 `val` 并计算 `len`。
- **重载操作符 `<`**：自定义排序规则，优先长度大的字符串，长度相同时按字典序排序。

#### 函数设计

1. **`string myitoa(int x)`**  
   将整数转换为字符串形式，辅助生成新整数序列。

2. **`long long count(int u, string subfix)`**  
   - 递归生成所有可能的整数，并将每个新生成的整数存入优先级队列。
   - **参数说明**：
     - `u`：当前递归整数。
     - `subfix`：当前整数的后缀。
   - **逻辑**：
     - 将当前整数与后缀组合形成新整数，存入优先级队列。
     - 递归调用，将小于等于 $ u/2 $ 的整数加入当前整数前。

### 3. 设计思路

1. **递归生成整数**  
   通过递归遍历所有可能的整数组合，利用优先级队列存储生成的结果，确保最终输出时按照排序规则排列。

2. **优先级队列使用**  
   使用 `priority_queue` 管理生成的整数，确保能根据指定规则快速获取排序后的结果。

## 四、实验结果

### 测试数据及结果

1. **测试用例 1**  
   - 输入：8  
   - 输出：
     Total=10
     8 18 28 38 48 128 138 148 248 1248
   - 结果：通过
2. **测试用例 2**  
   - 输入：4  
   - 输出：
   - Total=4
     4 14 24 124 
   - 结果：通过
3. **测试用例 3**  
   - 输入：15  
   - 输出：
   - Total=26
     15 115 215 315 415 515 615 715 1215 1315 1415 1515 1615 1715 2415 2515 2615 2715 3615 3715 12415 12515 12615 12715 13615 13715 
   - 结果：通过

## 五、实验分析与探讨

### 1. 测试结果分析

1）**功能验证**：  
实验结果表明，程序能够正确生成所有符合条件的整数并按要求输出，程序逻辑清晰，结果符合预期。

2）**优先级队列的合理性**：  
通过优先级队列管理生成的整数，能够有效保证输出顺序，且 `priority_queue` 的使用简化了排序过程。

### 2. 性能分析

1）**时间复杂度**：  
递归生成每个整数的时间复杂度为 $ O(n^2) $ 左右，优先级队列的插入操作为 $ O(\log n) $。对于 $ n $ 较大的情况，程序仍能较快运行。

若无需输出每个数字，通过记忆化搜索，问题的总体时间复杂度可进一步降低至$O(n\log n)$, 从而使n=2001的数据可以在1s内完成计算。 

2）**空间复杂度**：  
使用优先级队列存储所有可能的整数组合，空间复杂度为 $ O(n) $。在普通计算环境下，能够高效运行。

### 3. 实验设计和实现中的问题

1）**优先级队列的排序规则**  
描述：最初尝试使用普通队列，但输出顺序不符合要求。  
解决方法：采用优先级队列并自定义排序规则，确保按长度和字典序输出。

## 六、总结与反思

本实验通过递归方法和优先级队列的结合，完成了复杂的整数生成任务。优先级队列的使用极大简化了排序操作，并提高了程序的运行效率。实验过程中深刻体会到数据结构选择的重要性，以及递归方法在解决复杂问题中的优势。在今后的实验中，可以进一步优化递归逻辑和空间使用，提升程序的整体性能。