# 实验报告

## 一、问题描述及要求

### 1. 问题描述和要求

本实验的目标是使用C++设计并实现一个包含队列和栈的纸牌游戏，两个玩家轮流出牌，遵循特定的规则判断谁获胜。主要功能包括：

1. **队列和栈类的实现**：构建自己的队列和栈类，提供基本的入队、出队、入栈、出栈操作。
2. **游戏逻辑实现**：两名玩家轮流出牌，按照规则检查桌面上的牌并判断是否将牌返回手中，直至一名玩家牌出完。

示例：
- 输入牌序列：玩家A的牌为2 3 5 6 1，玩家B的牌为1 5 4 2 9
- 按照游戏规则逐步模拟，最终判断哪个玩家获胜。

## 二、概要设计

### 1. 系统功能列表

**队列类**：
- `enqueue(int value)`: 将值入队。
- `dequeue()`: 从队列头部出队并返回该值。
- `isEmpty()`: 判断队列是否为空。

**栈类**：
- `push(int value)`: 将值入栈。
- `pop()`: 从栈顶弹出值并返回该值。
- `peek()`: 返回栈顶元素。
- `isEmpty()`: 判断栈是否为空。
- `find(int value)`: 查找栈中是否存在特定值，返回其位置。
- `reset()`: 清空栈内容。

**游戏逻辑**：
- `playGame(Queue& playerA, Queue& playerB)`: 实现游戏逻辑，判断玩家的出牌和获胜情况。

### 2. 程序运行设计

程序要求用户输入玩家的牌序列并自动按轮次运行，最终输出胜者。

## 三、详细设计

### 1. 队列类 ADT

#### ADT Queue
**数据对象**：$\{a_i | a_i \in ElemSet, i=1,2,...,n, n \geq 0\}$

#### 基本操作：
1. **enqueue(Queue &Q, int value)**  
   将值插入到队列末尾。
2. **dequeue(Queue &Q)**  
   删除并返回队列头部元素。
3. **isEmpty(Queue Q)**  
   判断队列是否为空。

### 2. 栈类 ADT

#### ADT Stack
**数据对象**：$\{s_i | s_i \in ElemSet, i=1,2,...,n, n \geq 0\}$

#### 基本操作：
1. **push(Stack &S, int value)**  
   将值插入栈顶。
2. **pop(Stack &S)**  
   删除并返回栈顶元素。
3. **peek(Stack S)**  
   返回栈顶元素但不修改栈内容。
4. **find(Stack S, int value)**  
   查找指定元素并返回位置。
5. **reset(Stack &S)**  
   清空栈内容。

### 3. 设计思路

游戏实现采用两个循环控制游戏流程，利用队列和栈存储玩家的牌及桌面的牌。玩家轮流出牌并判断桌面上是否出现重复牌。若重复，则清除栈并将牌放回玩家手中。通过调用栈的`reset`方法清空桌面以避免无限循环。

## 四、实验结果

### 测试数据及结果

1. **测试用例 1**  
   - 输入：A的牌：2 3 5 6 1，B的牌：1 5 4 2 9  
   - 预期输出：B wins!  
   - 实际输出：B wins!  
   - 结果：通过

2. **测试用例 2**  
   - 输入：A的牌：1 2 3，B的牌：3 2 1  
   - 预期输出：A wins!  
   - 实际输出：A wins!  
   - 结果：通过

3. **测试用例 3**  
   - 输入：A的牌：2 2 2，B的牌：3 3 3  
   - 预期输出：B wins!  
   - 实际输出：B wins!  
   - 结果：通过

## 五、实验分析与探讨

### 1. 测试结果分析

1）**功能验证**：  
测试结果表明，程序能够根据题目要求完成基本功能，正确判断出最终的胜者。无论是队列还是栈的操作都符合预期。

2）**逻辑实现的合理性**：  
在游戏过程中，栈的`reset`操作能有效避免无限循环，使得程序能够顺利运行直至游戏结束。

### 2. 性能分析

1）**时间复杂度**：  
每个玩家在出牌时最多对桌面上的所有牌进行一次比较，因此时间复杂度为O(n^2)。对于常见数量的牌数，这样的时间复杂度可以接受。

2）**空间复杂度**：  
栈和队列的最大空间均为O(n)，程序的内存消耗相对较低，适合在普通计算环境下运行。

### 3. 实验设计和实现中的问题

1）**重复牌的处理逻辑**  
描述：最初程序中没有将重复牌清空，导致无限循环。  
解决方法：通过`reset`方法清空栈，确保不再无限循环。

## 六、总结与反思

在本实验中，我们通过手动实现队列和栈并完成一个简单的纸牌游戏逻辑，不仅加深了对数据结构的理解，还体验了如何通过这些数据结构来控制复杂游戏逻辑。在处理边界条件及无限循环问题时，体会到清晰的逻辑控制对实现稳定程序的重要性。  
实验中还存在进一步优化的空间，例如对栈操作中的效率改进及队列出牌逻辑的改良。